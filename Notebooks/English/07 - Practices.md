Docker is a platform that allows you to develop, test, and deploy applications as portable, self-sufficient containers that run virtually anywhere.

The `docker run` command creates a container from a given image and starts the container using a given command. It is one of the first commands you should become familiar with when starting to work with Docker.

In this article, we’ll use the official Nginx image to show various ways to run a Docker container.

The `docker run` command takes the following form:

```
docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
```

The name of the image from which the container should be created is the only required argument for the `docker run` command. If the image is not present on the local system, it is pulled from the registry.

If no command is specified, the command specified in the Dockerfile’s `CMD` or `ENTRYPOINT` instructions is executed when running the container.

Starting from version 1.13, the Docker CLI has been restructured. All commands have been grouped under the object they interact with.

Since the `run` command interacts with containers, it is a subcommand of `docker container`. The syntax of the new command is as follows:

```
docker container run [OPTIONS] IMAGE [COMMAND] [ARG...]
```

The old, pre 1.13 syntax is still supported. Under the hood, `docker run` command is an alias to `docker container run`. Users are encouraged to use the new command syntax.

A list of all `docker container run` options can be found on the [Docker documentation](https://docs.docker.com/engine/reference/commandline/container_run/) page.

## Run the Container in the Foreground

By default, when no option is provided to the `docker run` command, the root process is started in the foreground. This means that the standard input, output, and error from the root process are attached to the terminal session.

```
docker container run nginx
```

The output of the nginx process will be displayed on your terminal. Since there are no connections to the webserver, the terminal is empty.

To stop the container, terminate the running Nginx process by pressing `CTRL+C`.

## Run the Container in Detached Mode

To keep the container running when you exit the terminal session, start it in a detached mode. This is similar to running a [Linux process in the background](https://linuxize.com/post/how-to-run-linux-commands-in-background/) .

Use the `-d` option to start a detached container:

```
docker container run -d nginx
```

```
050e72d8567a3ec1e66370350b0069ab5219614f9701f63fcf02e8c8689f04fa
```

The detached container will stop when the root process is terminated.

You can list the running containers using the [`docker container ls`](https://linuxize.com/post/how-to-list-docker-containers/) command.

To attach your terminal to the detached container root process, use the [`docker container attach`](https://linuxize.com/post/how-to-connect-to-docker-container/) command.

## Remove the Container After Exit

By default, when the container exits, its file system persists on the host system.

The `--rm` options tells `docker run` command to remove the container when it exits automatically:

```
docker container run --rm nginx
```

The Nginx image may not be the best example to clean up the container’s file system after the container exits. This option is usually used on foreground containers that perform short-term tasks such as tests or database backups.

## Set the Container Name

In Docker, each container is identified by its `UUID` and name. By default, if not explicitly set, the container’s name is automatically generated by the Docker daemon.

Use the `--name` option to assign a custom name to the container:

```
docker container run -d --name my_nginx nginx
```

The container name must be unique. If you try to start another container with the same name, you’ll get an error similar to this:

```
docker: Error response from daemon: Conflict. The container name "/my_nginx" is already in use by container "9...c". You have to remove (or rename) that container to be able to reuse that name.
```

Run `docker container ls -a` to list all containers, and see their names:

```
docker container ls
```

```
CONTAINER ID  IMAGE  COMMAND                 CREATED         STATUS         PORTS   NAMES
9d695c1f5ef4  nginx  "nginx -g 'daemon of…"  36 seconds ago  Up 35 seconds  80/tcp  my_nginx
```

The meaningful names are useful to reference the container within a Docker network or when running docker CLI commands.

## Publishing Container Ports

By default, if no ports are published, the process running in the container is accessible only from inside the container.

Publishing ports means mapping container ports to the host machine ports so that the ports are available to services outside of Docker.

To publish a port use the `-p` options as follows:

```
-p host_ip:host_port:container_port/protocol
```

-   If no `host_ip` is specified, it defaults to `0.0.0.0`.
-   If no `protocol` is specified, it defaults to TCP.
-   To publish multiple ports, use multiple `-p` options.

To map the TCP port 80 (nginx) in the container to port 8080 on the host localhost interface, you would run:

```
docker container run --name web_server -d -p 8080:80 nginx
```

You can verify that the port is published by opening `http://localhost:8080` in your browser or running the following [`curl`](https://linuxize.com/post/curl-command-examples/) command on the Docker host:

```
curl -I http://localhost:8080
```

The output will look something like this:

```
HTTP/1.1 200 OK
Server: nginx/1.17.6
Date: Tue, 26 Nov 2019 22:55:59 GMT
Content-Type: text/html
Content-Length: 612
Last-Modified: Tue, 19 Nov 2019 12:50:08 GMT
Connection: keep-alive
ETag: "5dd3e500-264"
Accept-Ranges: bytes
```

## Sharing Data (Mounting Volumes)

When a container is stopped, all data generated by the container is removed. Docker Volumes are the preferred way to make the data persist and share it across multiple containers.

To create and manage volumes, use the `-p` options as follows:

```
-v host_src:container_dest:options
```

-   The `host_src` can be an absolute path to a file or directory on the host or a named volume.
-   The `container_dest` is an absolute path to a file or directory on the container.
-   Options can be `rw` (read-write) and `ro` (read-only). If no option is specified, it defaults to `rw`.

To explain how this works, let’s [create a directory](https://linuxize.com/post/how-to-create-directories-in-linux-with-the-mkdir-command/) on the host and put an `index.html` file in it:

```
mkdir public_html
```

Next, mount the `public_html` directory into `/usr/share/nginx/html` in the container:

```
docker run --name web_server -d -p 8080:80 -v $(pwd)/public_html:/usr/share/nginx/html nginx
```

Instead of specifying the absolute path to the `public_html` directory, we’re using the `$(pwd)` command, which prints the [current working directory](https://linuxize.com/post/current-working-directory/) .

Now, if you type `http://localhost:8080` in your browser, you should see the contents of the `index.html` file. You can also use `curl`:

```
curl http://localhost:8080
```

```
Testing Docker Volumes
```

## Run the Container Interactively

When dealing with the interactive processes like `bash`, use the `-i` and `-t` options to start the container.

The `-it` options tells Docker to keep the standard input attached to the terminal and allocate a pseudo-tty:

```
docker container run -it nginx /bin/bash
```

The container’s Bash shell will be attached to the terminal, and the command prompt will change:

```
root@1da70f1937f5:/#
```

Now, you can interact with the container’s shell and run any command inside of it.

In this example, we provided a command (`/bin/bash`) as an argument to the `docker run` command that was executed instead of the one specified in the Dockerfile.

## Conclusion

Docker is the standard for packaging and deploying applications and an essential component of CI/CD, automation, and DevOps.

The `docker container run` command is used to create and run Docker containers.

If you have any questions, please leave a comment below.